var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = CodecLZOP","category":"page"},{"location":"#CodecLZOP","page":"Home","title":"CodecLZOP","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CodecLZOP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [CodecLZOP]","category":"page"},{"location":"#CodecLZOP.LZOPCompressor","page":"Home","title":"CodecLZOP.LZOPCompressor","text":"LZOPCompressor([algo=LZO1X_1]; <keyword arguments>) <: TranscodingStreams.Codec\n\nCompress data using the LZOP method.\n\nArguments\n\nalgo: LibLZO.AbstractLZOAlgorithm, Type{LibLZO.AbstractLZOAlgorithm}, Symbol, or AbstractString describing the LZO algorithm to use when compressing the data.\n\nKeyword Arguments\n\nblock_size::Integer = LZOP_DEFAULT_BLOCK_SIZE: the maximum size of each block into which the input data will be split before compressing with LZO. Cannot be greater than 64 * 2^20 (64 MB).\nuncompressed_checksum::Union{Symbol, Nothing} = :adler32: can be any of the following values:\n:adler32: write an Adler32 checksum of the uncompressed data (default).\n:crc32: write a CRC32 checksum of the uncompressed data.\nnothing: do not write a checksum of the uncompressed data.\ncompressed_checksum::Union{Symbol, Nothing} = nothing: can be any of the following values:\n:adler32: write an Adler32 checksum of the compressed data.\n:crc32: write a CRC32 checksum of the compressed data.\nnothing: do not write a checksum of the compressed data (default).\nfilter::Function = identity: a function applied to the compressed data as it is streamed. The function must take a single AbstractVector{UInt8} argument and modify it in place without changing its size.\noptimize::Bool = false: whether to run the LZO optimization function on compressed data before writing it to the stream. Optimization doubles the compression time and rarely results in improved compression ratios, so it is disabled by default.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZOP.LZOPCompressorStream","page":"Home","title":"CodecLZOP.LZOPCompressorStream","text":"LZOPCompressorStream(io, [algo=LZO1X_1]; <keyword arguments>) <: TranscodingStreams.TranscodingStream\n\nCompress stream using the LZOP method.\n\nArguments\n\nio::IO: stream to compress.\nalgo: LibLZO.AbstractLZOAlgorithm, Type{LibLZO.AbstractLZOAlgorithm}, Symbol, or AbstractString describing the LZO algorithm to use when compressing the data.\n\nKeyword Arguments\n\nblock_size::Integer = LZOP_DEFAULT_BLOCK_SIZE: the maximum size of each block into which the input data will be split before compressing with LZO. Cannot be greater than 64 * 2^20 (64 MB).\nuncompressed_checksum::Union{Symbol, Nothing} = :adler32: can be any of the following values:\n:adler32: write an Adler32 checksum of the uncompressed data (default).\n:crc32: write a CRC32 checksum of the uncompressed data.\nnothing: do not write a checksum of the uncompressed data.\ncompressed_checksum::Union{Symbol, Nothing} = nothing: can be any of the following values:\n:adler32: write an Adler32 checksum of the compressed data.\n:crc32: write a CRC32 checksum of the compressed data.\nnothing: do not write a checksum of the compressed data (default).\nfilter::Function = identity: a function applied to the compressed data as it is streamed. The function must take a single AbstractVector{UInt8} argument and modify it in place without changing its size.\noptimize::Bool = false: whether to run the LZO optimization function on compressed data before writing it to the stream. Optimization doubles the compression time and rarely results in improved compression ratios, so it is disabled by default.\n\nAll other keyword arguments are passed unmodified to the TranscodingStream constructor.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZOP.LZOPDecompressor","page":"Home","title":"CodecLZOP.LZOPDecompressor","text":"LZOPDecompressor([algo=LZO1X_1]; <keyword arguments>) <: TranscodingStreams.Codec\n\nDexompress data using the LZOP method.\n\nArguments\n\nalgo: LibLZO.AbstractLZOAlgorithm, Type{LibLZO.AbstractLZOAlgorithm}, Symbol, or AbstractString describing the LZO algorithm to use when decompressing the data. The decompression algorithm must match the algorithm used to compress the data.\n\nKeyword Arguments\n\nuncompressed_checksum::Union{Symbol, Nothing} = :adler32: can be any of the following values:\n:adler32: expect and decode an Adler32 checksum of the uncompressed data (default).\n:crc32: expect and decode a CRC32 checksum of the uncompressed data.\nnothing: expect no checksum of the uncompressed data.\ncompressed_checksum::Union{Symbol, Nothing} = nothing: can be any of the following values:\n:adler32: expect and decode an Adler32 checksum of the compressed data.\n:crc32: expect and decode a CRC32 checksum of the compressed data.\nnothing: expect no checksum of the compressed data (default).\nfilter::Function = identity: a function applied to the decompressed data as it is streamed. The function must take a single AbstractVector{UInt8} argument and modify it in place without changing its size.\non_checksum_fail::Symbol = :throw: a flag to determine how checksum failures are handled. :throw will cause an ErrorException to be thrown, :warn will log a warning using the @warn macro, and :ignore will silently ignore the failure.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZOP.LZOPDecompressorStream","page":"Home","title":"CodecLZOP.LZOPDecompressorStream","text":"LZOPDecompressorStream(io, [algo=LZO1X_1]; <keyword arguments>) <: TranscodingStreams.TranscodingStream\n\nDexompress data using the LZOP method.\n\nArguments\n\nio::IO: stream to decompress.\nalgo: LibLZO.AbstractLZOAlgorithm, Type{LibLZO.AbstractLZOAlgorithm}, Symbol, or AbstractString describing the LZO algorithm to use when decompressing the data. The decompression algorithm must match the algorithm used to compress the data.\n\nKeyword Arguments\n\nuncompressed_checksum::Union{Symbol, Nothing} = :adler32: can be any of the following values:\n:adler32: expect and decode an Adler32 checksum of the uncompressed data (default).\n:crc32: expect and decode a CRC32 checksum of the uncompressed data.\nnothing: expect no checksum of the uncompressed data.\ncompressed_checksum::Union{Symbol, Nothing} = nothing: can be any of the following values:\n:adler32: expect and decode an Adler32 checksum of the compressed data.\n:crc32: expect and decode a CRC32 checksum of the compressed data.\nnothing: expect no checksum of the compressed data (default).\nfilter::Function = identity: a function applied to the decompressed data as it is streamed. The function must take a single AbstractVector{UInt8} argument and modify it in place without changing its size.\non_checksum_fail::Symbol = :throw: a flag to determine how checksum failures are handled. :throw will cause an ErrorException to be thrown, :warn will log a warning using the @warn macro, and :ignore will silently ignore the failure.\n\nAll other keyword arguments are passed unmodified to the TranscodingStream constructor.\n\n\n\n\n\n","category":"type"},{"location":"#CodecLZOP.compress_block-Union{Tuple{F}, Tuple{AbstractVector{UInt8}, IO, LibLZO.AbstractLZOAlgorithm}} where F<:Function","page":"Home","title":"CodecLZOP.compress_block","text":"compress_block(input, output, algo; [kwargs...])::Tuple{Int,Int}\n\nCompress a block of data from input to output using LZO algorithm algo, returning the number of bytes read from input and written to output.\n\nArguments\n\ninput: An AbstractVector{UInt8} or IO object containing the block of data to compress.\noutput::IO: Output IO object to write the compressed block.\n\nKeyword arguments\n\nblock_size::Integer = LZOP_DEFAULT_BLOCK_SIZE: Number of bytes to read from input. Will cap at LZOP_MAX_BLOCK_SIZE.\nuncompressed_checksum::Union{Symbol, Nothing} = :adler32: can be any of the following values:\n:adler32: write an Adler32 checksum of the uncompressed data (default).\n:crc32: write a CRC32 checksum of the uncompressed data.\nnothing: do not write a checksum of the uncompressed data.\ncompressed_checksum::Union{Symbol, Nothing} = nothing: can be any of the following values:\n:adler32: write an Adler32 checksum of the compressed data.\n:crc32: write a CRC32 checksum of the compressed data.\nnothing: do not write a checksum of the compressed data (default).\nfilter_function::Function = identity: Transform the input data using the specified filter functions. The filter function must accept a single AbstractVector{UInt8} argument and must modify that vector in-place.\noptimize::Bool = false: If true, process the data twice to optimize how it is stored for faster decompression. Setting this to true doubles compression time with little to no improvement in decompression time, so its use is not recommended.\n\n\n\n\n\n","category":"method"},{"location":"#CodecLZOP.decompress_block-Union{Tuple{F}, Tuple{IO, IO, LibLZO.AbstractLZOAlgorithm}} where F<:Function","page":"Home","title":"CodecLZOP.decompress_block","text":"decompress_block(input, output, algo; [kwargs...])::Tuple{Int,Int}\n\nDecompress a block of data from input to output using LZO algorithm algo, returning the number of bytes read from input and written to output.\n\nArguments\n\ninput: An AbstractVector{UInt8} or IO object containing the block of LZO-compressed data to decompress.\noutput::IO: Output IO object to write the decompressed block.\n\nKeyword arguments\n\nuncompressed_checksum::Union{Symbol, Nothing} = :adler32: can be any of the following values:\n:adler32: expect and decode an Adler32 checksum of the uncompressed data (default).\n:crc32: expect and decode a CRC32 checksum of the uncompressed data.\nnothing: expect no checksum of the uncompressed data.\ncompressed_checksum::Union{Symbol, Nothing} = nothing: can be any of the following values:\n:adler32: expect and decode an Adler32 checksum of the compressed data.\n:crc32: expect and decode a CRC32 checksum of the compressed data.\nnothing: expect no checksum of the compressed data (default).\nfilter_function::Function = identity: Untransform the output data using the specified filter function. The filter function must take a single AbstractVector{UInt8} argument and modify it in place.\non_checksum_fail::Symbol = :throw: Choose how the function responds to invalud checksums. If :throw, an ErrorException will be thrown. If :warn, a warning will be printed. If :ignore, the checksum values will be completely ignored.\n\n\n\n\n\n","category":"method"}]
}
